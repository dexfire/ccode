#include <cmath>
#include <cstdio>
#include <iostream>
#include <string>
using namespace std;
int n;
/***
 * 原始汉诺塔问题
 * ==============
 * 初始状态是
 *          A柱：x个盘      B柱：0个盘       C柱：0个盘
 *
 * 移动规则
 *          1、一次只能移动一个盘
 *          2、任何时候都不能大盘压小盘的情况
 *
 * 解决方案：
 *      首先我们分解问题 ，把 x 个盘分解成 1个盘 + x-1个盘，
 *          分3步解决问题：
 *          ①把x-1个盘移到中转站B柱
 *          ②把最大的一个盘从A柱移到C柱
 *          ③把B柱上剩余的盘移到C柱
 *
 *          1、将 x-1 个盘 从 A 移动到 B，将 C 为中转站【起初b、c都是空的】
 *                  结果： A柱：1个盘      B柱：x-1个盘       C柱：0个盘
 *
 *          2、将 剩余一个盘移到 C，不用中转
 *                  结果： A柱：0个盘      B柱：x-1个盘       C柱：1个盘
 *
 *          3、将 B 的 x-1 个盘移到 C 上，B 为中转站
 *                  结果： A柱：0个盘      B柱：0个盘           C柱：x个盘
 *
 * ===============
 * 这样看似问题就已经解决了，但是还有一些“奇怪”的问题：
 *      1、怎么移动 x-1 个盘？
 *              如果 (x-1) = 1 的话，问题就好办了，
 *              因为只有一个盘，直接移过去就ok了
 *              如果不只一个呢？ 那么我们可以用刚刚那样的相同的模式来解决！
 *                  步骤一中 “将 x-1 个盘 从 A 移动到 B，将 C 为中转站”
 *      2、中转站有什么作用？
 *              和它的名字一样，中转。考虑只有两个盘的情况
 *                      2 0 0 -> 1 1 0 -> 0 1 1
 *      2、第一步时，为什么可以把B作为中转站？
 *              首先，第一次移动的时候，B柱是空的，所以是可以做到的。
 *              其次，步骤1和步骤3中分别有两个递归过程，这个过程中不会违反规则吗？
 */

void move(int x, string a, string b, string c) {
    if (x == 1) {
        cout << "move " << a << " --> " << c << endl;
        return;
    }
    move(x - 1, a, c, b);
    cout << "move " << a << " --> " << c << endl;
    move(x - 1, b, a, c);
}

int main() {
    while (~scanf("%d", &n)) {
        move(n, "A", "B", "C");
    }
    return 0;
}